## Study_JS

### 프로그램
	소스코드로 잘 짜여진 틀.	

### 프로그래밍 언어
	컴퓨터와 개발자가 소통하기 위한 언어.

### 소스코드
	개발자가 컴퓨터와 대화하는 내용.

### 소스파일
	소스코드가 작성된 파일.

### 컴파일
	사람의 언어를 컴퓨터 언어로 번역하는 작업.

### 컴파일러
	컴파일 해주는 것.(번역기)

### 컴파일 과정
	디버그(오류를 검사하는 과정) → 빌드 → 링크 → 실행

### 인터프리터
	사람의 언어를 컴퓨터 언어로 번역해주는 번역기
	번역과 동시에 실행. → 번역 파일이 생성되지 않는다.

### 인터프리터 언어(스크립트 언어)
	한 줄씩 번역.
	한 번에 모두 번역하는 것보다 비효율적일 수 있지만, 기존의 코드를 재실행할 필요가 없을 경우에는 훨씬 효과적임.
	
### 자바 스크립트(Javascript)
	컴파일 과정 없이 브라우저 내부의 자바스크립트 처리기(인터프리터)에 의해 바로 실행.
	* 개발이 발전됨에 따라 컴파일 과정이 가능해졌으며, Node.js 서버 환경을 구축함.

### 웹 페이지에서 자바스크립트의 역할
	웹 페이지는 3가지(HTML, CSS, JS) 코드가 결합되어 작성됨.
	자바스크립트는 사용자의 입력을 처리하거나 웹 애플리케이션을 작성하는 등
	웹 페이지의 동적 제어에 사용됨.

	- 사용자의 입력 및 연산
		키, 마우스 등의 입력과 연산은 오직 자바스크립트로만 처리가 가능함.

	- 웹 페이지 내용 및 모양의 동적 제어
		HTML 태그의 속성이나 콘텐츠, CSS 속성 값을 변경해서
		웹 페이지의 동적인 변화를 일으키는 데에 활용됨.

	- 브라우저 제어(DOM)
		브라우저 윈도우 크기나 모양 변경, 새 윈도우나 탭 열기, 다른 웹 사이트 접속,
		브라우저의 히스토리 제어 등 브라우저의 작동을 제어하는 데 활용됨.

	-웹 서버와의 통신(fetch, 비동기 통신)
		웹 페이지가 웹 서버와 데이터를 주고 받을 때 활용.

	- 웹 애플리케이션 작성(ex. 카카오맵)
		자바스크립트 언어로 활용될 수 있는 많은 API를 제공하므로,
		웹 브라우저에서 실행되는 다양한 웹 애플리케이션을 개발할 수 있음.


### 자바스크립트를 작성할 수 있는 위치
	1. HTML 태그의 이벤트 리스너 속성에 작성(value로 작성)
		HTML 태그에는 마우스가 클릭되거나 키보드의 키가 입력되는 등의 이벤트가 발생할 때,
		처리되는 코드를 등록하는 리스너 속성이 있음.

	2. <script></script> 태그 안에 작성
		<head></head>, <body></body>, body태그 밖 등 어디든 들어갈 수 있음.
		웹 페이지 내에서 여러 번 작성할 수 있음.

	3. .js 자바스크립트 파일에 작성
		자바스크립트 코드를 확장자가 .js인 별도의 파일로 저장하고
		<script src="[.js 경로]"></script>

	4. URL 부분에 작성
		<a> 태그의 href 속성에도 자바스크립트 코드를 작성할 수 있음.
		하지만 href 속성에서 자바스크립트 코드를 작성할 때에는 "javascript:" 라는 키워드를 작성한 뒤
		JS 코드를 작성.

### 데이터 타입과 변수
	변수는 저장공간이다.

			X    			= 			10
	(저장공간의 이름) (대입 연산자) (값 = 상수)
	
	1. 자바스크립트 식별자(이름)
		식별자(Identifier)란 자바스크립트 개발자가 변수,상수,함수에 붙이는 이름을 뜻함.
		식별자를 만들 때 다음 규칙을 준수해야 함.
		
		- 첫 번째 문자 : 알파벳, 언더바, $문자만 사용가능
		- 두 번째 이상 문자 : 알파벳 언더바, 0~9, $ 사용가능
		- 대소문자 구분 : data와 dAta는 다른 식별자임.
		- 키워드(예약어)는 사용불가. 자바스크립트에서 이미 사용 중인 단어들.

	2. 변수의 선언
		- var 키워드 : 함수의 {}만 영역으로 취급.
			var data = 10;
			

		- let 키워드 : 모든 {}를 영역으로 취급.
			let data = 10;
						
	3. 변수의 사용
		사용한 변수가 저장 공간인지 값인지를 명확히 구분할 수 있어야 함.

	4. 주소
		ex) let x=10;
		x라는 이름의 저장공간이 RAM에 생성 및 할당되고 이 때, 고유한 주소 값이 부여된다.
		
		주소를 알고 있으면 어디서든지 찾아갈 수 있음.


	5. 데이터 타입(자료형)
		저장 공간의 종류를 타입 또는 자료형이라고 함.
		자바스크립트는 값에 따라 저장 공간의 종류가 알맞게 바뀌기 때문에 이를 동적 바인딩이라고 함.
		
		* 숫자 타입(number) : 42, 3.14... 등등 정수 + 실수
		* 논리 타입(boolean) : true, false
		* 문자열 타입(string) : '문자' "문자열"
		* 객체 레퍼런스 타입(object) : Object, Array, Math, Date, ...
			
		1. undefined : 타입이 정해지지 않은 것을 의미.
		2. null : 값이 정해지지 않은 것을 의미.

	6. 지역 변수와 전역 변수
		변수의 사용 범위(scope)에 따라서 전역 변수(global)와 지역 변수(local)로 나뉨.

		전역 변수를 선언할 때에는 globalThis에 선언!

		전역 변수 : 영역 밖에 선언된 변수.

		지역 변수 : 영역 안에 선언된 변수.


	7. 변수를 사용하는 이유
		1. 반복되는 값을 쉽게 관리하기 위해서.
		2. 의미 없는 값을 하나의 정보로 만들기 위해서.(자료구조)


### 상수
	항상 그대로인 수.
	절대 다른 곳에서 변하지 못하게 하는 선언 방법.

	const 식별자 = 값;	


### 출력 함수
	개발자를 위한 도구이다.
	console.log("");
	
### 출력 함수를 사용하는 이유
	1. 값을 확인하기 위해 사용함.
	2. 오류를 구체화하기 위해 사용함.
	
	console.log("들어옴1")
	A 코드
	console.log("들어옴2")
	B 코드
	console.log("들어옴3")
	C 코드
	console.log("들어옴4")
	D 코드
	console.log("들어옴5")
	E 코드
	console.log("들어옴6")

	일반적으로 위에서 아래 방향으로 코드가 실행되므로, 출력 결과를 통해 오류가 발생한 위치를 구체화 할 수 있음.

### 연산자
	기능이 있는 특수문자.

### 연산자의 우선순위
	하나의 수식에 다양한 연산자가 섞여 있으면, 우선순위에 따라 순서대로 연산됨.

	최우선 연산자 → 단항 연산자 → 산술 연산자 → 쉬프트 연선자 →	관계 연산자 → 논리 연산자 →	삼항 연산자 → 대입 연산자

### 연산자의 결합성 
	하나의 수식에 하나의 연산자가 여러 개 사용되었을 때, 어떤 방향으로 결합되어 연산되는지를 나타내주는 성질.
	대입 연산자만 우 -> 좌 방향.

### 조건식
	참 또는 거짓 중 하나가 나오는 식.
	반드시 값으로 봐야 함.

### 조건식에서 사용되는 연산자
		
	관계 연산자
	==		:같다
	===		:같다(자료형도 같을 때)
	!=		:같지 않다
	!==		:같이 않다
	>, <	:초과, 미만(자료형도 같지 않을 때)
	>=, <=	:이상, 이하

	논리 연산자
	&&(and) A && B : A,B 모두 true여야 true
	||(OR), A || B : 둘 중 하나라도 true면 true	


	단항 연산자			
	! NOT, !a a가 false이면 true로 true이면 false로 변경.
	
	삼항 연산자 (? :)
	(조건식) ? (참) : (거짓)  → 이 때 결과를 값으로 생각해야 한다.


### 제어문 
	기존의 코드 흐름을 제어하여, 원하는 흐름으로 바꿀 수 있는 문법.
	
####	1. 조건문
	* if문
		if(조건식){ 위의 조건식과 관계 없이 항상 모두 검사
				(실행 내용);
		}
		else if(조건식){ 위의 조건식과 관계 있고, 참일 경우 검사 끝.
				(실행 내용);
		}
		else{
				(실행 내용);
		}
		if(조건식){
				(실행 내용);
		}

	* switch문
		
		switch(값){
			case 값1:
				(실행내용);
				break;
			case 값2:
				(실행내용);
				break;
			case 값3:
				(실행내용);
				break;
				.......
			default:
				(실행내용);
				break;
		}

#####	* 삼항 연산자, 'if'문 그리고 'switch'문

	* 삼항 연산자 : 조건식이 1개 있을 때에만 사용하는 것이 보기에 좋음.
	* if 문 : 다양한 비교 혹은 여러 개의 조건식을 연결해야할 때 사용하는 것이 좋음.
	* switch문 : 하나의 변수에 여러 종류의 값이 담길 수 있고 이를 같은 지 비교할 떄 사용하는 것이 좋음.

####	2. 반복문
	* 대입 연산자(복합 대입 연산자, 누적 연산자)
		let money = 10000;
		money = money-1000;
		money -= 1000 ;
		console.log(money)

		
	* 증감 연산자
		둘 다 사용해도 되는 상황에서는 후위형을 사용.
		1. 전위형 : 해당 라인부터 바로 적용
		++data
	
		2. 후위형 : 다음 라인부터 바로 적용
		data++ 

		ex) for문에서의 사용 예시

		for([초기식]; [조건식]; [증감식];){
			실행 내용;
		} 
		초기식 -> 조건식 -> 실행 -> 증감식 -> 조건식 -> 실행 -> 증감식 ............ 탈출


####	3. 기타 제어문

	* break 
		컴파일러가 만나는 즉시 해당 중괄호 영역을 탈출한다 .
		if문 안에서 break를 사용하면 if문 탈출이 아닌 if문을 감싸고 있는 영역을 탈출.

	* continue
		컴파일러가 만나는 즉시 다음 반복으로 넘어감.
		continue 밑에 있는 문장을 실행하지 않을 때 사용.
		continue 밑에 실행할 문장이 아무것도 없으면 사용할 이유가 사라진다

	* while 문
		while(조건식){
				실행할 문장;
		}

	* do~while 문 : 최초 한 번은 실행시키기 위한 것.
		do{
		실행할 문장;
		}
		while(조건식);

	*** 반복횟수를 알면 for문, 모르면 while문.


### 함수 
	이름 뒤에 소괄호를 붙이는 형태로 선언한다. 단, 키워드 뒤에 소괄호는 함수가 아니다.
	함수는 저장공간이고, 리턴 값이 있다면 값으로 본다.

	   f              (x)           =   2x+1
	함수명        매개(변수)           리턴값

### 함수의 선언
	function (1)함수명 ((2)매개변수1, 매개변수2){

    (3)실행할 문장;

    (4)return 리턴값;
	
	}

	(1) 동사로 작성. ex) getPrice, calc 

	(2) 외부에서 전달받을 값이 있다면, 순서에 맞게 선언
    	생략이 가능하지만, 외부에서 값을 전달받을 수 없게 됨.

	(3) 생략 가능. 메소드의 기능을 구현하는 로직을 작성.

	(4) 생략 가능. 리턴값이 있다면, 사용한 부분 통째로 리턴값으로 봄.

### 함수 선언 순서
	1. 함수 이름. 
	2. 매개 변수.
	3. 실행할 문장 작성.

### 함수의 선언과 사용.
	중괄호가 있으면 선언, 없으면 사용.

	함수를 사용할 대에는 아래와 같이 사용.

	매개 변수가 있을 때 :	함수명(값1,...)

	매개 변수가 없을 때 :	함수명();

### 함수를 사용하는 이유
	1. 재사용의 목적(단, 특정성을 부여해서는 안됨.)
	2. 소스코드 간결화의 목적	


### 객체
	추상적인 개념을 구체화시켜 놓은 것.

	한 자리에 모아놓았던 공통 요소를 사용하고자 할 때 객체로 만들어 사용한다.

	{}로 작성하면 객체이고, 이에 이름을 붙여 사용한다.

	이 때, 중괄호 안에 선언된 필드를 프로퍼티(property)라고 부른다.

	프로퍼티를 사용할 때에는 객체명 뒤에 마침표를 작성하여 접근한다.
	
	* 선언 예시
	const hong = {
		name: "홍길동",
		age: 20
	}

	* 사용 예시
	1. hong.name, hong.age
	2. hong["name"], hong["age"] : 만약 프로퍼티의 key값에 특수문자가 포함되어 있으면 대괄호 안에 문자열형태로 작성해야한다.

### 생성자
	프로퍼티를 메모리에 할당해주고, 할당된 영역의 주소값을 가져와준다.
	
	함수의 기능과 똑같지만, 리턴을 사용할 수 없기 때문에 함수라고 부를 수 없다.

	따라서, 생성자 이름은 앞글자를 대문자로 시작한다.

	앞으로는 공통된 프로퍼티가 계속해서 등장하면, 생성자를 선언하여 하나로 묶고	딱 한 번만 선언하도록 한다.

	function 이름 (매개변수1, 매개변수2, ...) {
		실행할 문장;
	}

### this
	생성자 선언시, 어떤 객체가 접근하는지 알아야 해당 프로퍼티로 접근하여 초기화할 수 있다.
	따라서 아래와 같이 접근한 객체의 주소를 받아와야 한다.

	function 이름(address, 매개변수1, ...){
		address.(프로퍼티)
	}

	하지만 이렇게 매번 주소를 받아오는 것은 개발자에게 불편한 일이기 때문에
	JS에서는 자동으로 접근한 객체의 주소를 받게되고 이는 this라는 변수에 들어간다.
	따라서 앞으로는 this를 사용하여 프로퍼티를 접근한다.

	function 이름(매개변수1, ...){
		this.(프로퍼티)
	}

### 프로토타입(prototype)
	모든 객체가 공유해야하는 프로퍼티를 선언해놓는 공간이다.
	객체로 접근하지 않고, 생성자명에서 prototype을 접근한 뒤 사용해야 한다.
	
	생성자명.prototype.[공유할 프로퍼티명]

### Array
	저장공간의 나열.

	1. 변수를 여러개 선언하게 되면, 이름도 여러개 생기기 때문에 관리하기 어렵다.
	   Array객체를 선언하면, 여러칸을 한 개의 이름으로 관리할 수 있기 때문에 관리하기 쉽다.

	2. 규칙성이 없는 값에 규칙성을 부여할 수 있다.
